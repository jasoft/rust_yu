## Context

当前后端已经能从注册表读取安装软件列表，并在 `InstalledProgram` 中携带 `install_date`、`icon_path`、`estimated_size` 等字段，但存在三个问题：
- 字段语义不统一：日期格式未标准化、图标路径可能带参数、大小来源不透明。
- 数据完整性不足：部分应用仅有部分字段，前端难以区分“真实为空”与“未能解析”。
- 性能与重复扫描：每次列表请求都可能触发重复 I/O，现有 `storage` 更偏快照保存，不是面向“可控失效”的读取缓存。

此次变更是跨模块改动（`lister`、Tauri command、前端展示），并且包含性能与一致性约束，因此需要先明确技术设计。

## Goals / Non-Goals

**Goals:**
- 提供稳定、可解释的增强元数据：图标、安装日期、占用空间及其来源/置信度。
- 建立“注册表基础扫描 + 元数据增强 + 缓存读写”的统一流水线。
- 引入可控缓存策略（命中、失效、重建、强制刷新），减少重复全量扫描耗时。
- 保证高开销操作异步化，避免阻塞 Tauri UI 线程。
- 在字段缺失或不确定时保持保守策略，返回低置信度或空值，而不是猜测。

**Non-Goals:**
- 不在本次实现中做“绝对精确”的全盘占用空间核算（例如跨盘符全部残留逐文件统计）。
- 不改动卸载/清理删除逻辑，仅增强“列表与展示”链路。
- 不在本次引入远程服务或云端缓存。

## Decisions

### 1) 元数据模型采用“值 + 来源 + 置信度”设计
- Decision: 在现有 `InstalledProgram` 基础上补充标准化字段和来源信息（例如 `install_date_source`、`size_source`、`metadata_confidence`），并保持对旧字段的向后兼容。
- Alternatives considered:
  - 仅保留当前扁平字段，不增加来源信息。
  - 引入全新的嵌套对象并移除旧字段。
- Rationale: 仅靠值不足以支撑 UI 判断；完全重构对象会放大前后端改造成本。渐进增强可兼顾可读性与兼容性。

### 2) 扫描流程采用“两阶段聚合”
- Decision:
  - 阶段 A（快速）：读取卸载注册表项，构建基础程序列表。
  - 阶段 B（增强）：并发补齐图标、安装日期标准化、占用空间（优先 `EstimatedSize`，必要时回退目录扫描）。
- Alternatives considered:
  - 单阶段串行读取并一次性计算所有字段。
  - 每次请求都执行完整目录大小扫描。
- Rationale: 两阶段可以先快速返回基础结果，再在可控范围内补齐重字段；避免一次请求被少量慢目录拖死。

### 3) 图标解析采用“可执行路径优先，保守回退”
- Decision:
  - 首选 `DisplayIcon`，清洗参数（如 `",0"`、命令行参数）后校验文件存在。
  - 失败时尝试 `InstallLocation` 下候选可执行文件。
  - 仍失败则返回空值并标记低置信度，不伪造图标。
- Alternatives considered:
  - 强制提取并缓存二进制图标数据（base64）。
  - 仅返回 `DisplayIcon` 原始字符串不做清洗。
- Rationale: 路径引用对当前 UI 足够且开销低；直接缓存二进制会增大缓存体积与复杂度。

### 4) 占用空间策略采用“估算优先 + 限流回退计算”
- Decision:
  - 优先使用注册表 `EstimatedSize`（KB）并转换为字节。
  - 当 `EstimatedSize` 缺失且 `InstallLocation` 可信时，使用后台限流目录扫描计算。
  - 目录扫描需设置并发上限与超时，超时则返回未知/低置信度。
- Alternatives considered:
  - 永远不做目录扫描，仅显示估算值或空值。
  - 默认对所有程序都做目录全量扫描。
- Rationale: 估算值可覆盖大量场景；回退计算提高可用性；限流与超时避免 UI 卡顿和磁盘抖动。

### 5) 缓存采用“本地版本化文件 + 显式失效”
- Decision:
  - 在本地应用数据目录保存版本化缓存（例如 `installed_programs_cache_v1.json`），内容包含 `generated_at`、`schema_version`、`entries`。
  - 命令层提供 `refresh` 开关：`refresh=true` 强制重建；默认优先读缓存并按 TTL/失效条件决定是否重扫。
  - 卸载成功后触发相关条目失效或整体失效，避免长期脏数据。
- Alternatives considered:
  - 完全复用现有 `programs.json` 快照，不加版本与失效元数据。
  - 改用 SQLite 作为首版缓存。
- Rationale: 版本化 JSON 改造成本最低，且便于调试；保留未来迁移到 SQLite 的空间。

### 6) 并发与错误处理遵循“部分成功可返回”
- Decision:
  - I/O 密集任务在 `tauri::async_runtime::spawn_blocking` 或受控异步任务中执行。
  - 任一字段解析失败不影响整个列表返回，记录日志并降级为空值/低置信度。
  - 避免在关键路径使用 `unwrap/expect`，统一通过 `Result` 传播并在 command 层转换。
- Alternatives considered:
  - 任一增强步骤失败即整体失败。
  - 保持当前同步调用方式不做并发控制。
- Rationale: 列表场景更适合“尽量返回”；并发控制可在保证稳定性的同时提升感知性能。

## Risks / Trade-offs

- [Risk] 目录大小扫描在大体量安装目录上仍可能耗时较长  
  → Mitigation: 默认优先估算值、限制并发、单任务超时、允许前端按需刷新。

- [Risk] 缓存命中导致展示旧数据（刚卸载/刚安装）  
  → Mitigation: 增加 TTL、提供 `refresh`、在卸载流程后主动失效缓存。

- [Risk] 图标路径兼容性问题（参数、相对路径、权限）  
  → Mitigation: 统一路径清洗与存在性校验，失败时降级为空并标记来源。

- [Risk] 元数据字段扩展引发前后端类型不一致  
  → Mitigation: 在命令返回模型中为新增字段使用 `Option` + 明确默认值，并同步更新 TS 类型。

## Migration Plan

1. 扩展 `InstalledProgram` 及相关序列化模型，新增元数据来源/置信度字段（保持向后兼容）。
2. 在 `lister` 增加元数据增强模块（日期标准化、图标解析、占用空间回退计算）。
3. 扩展 `storage` 为版本化缓存结构，加入 TTL/失效信息与读写接口。
4. 更新 Tauri `list_programs` 命令参数与返回结构，支持 `refresh` 等控制选项。
5. 前端列表接入新增字段，展示缓存状态与低置信度提示。
6. 在卸载成功路径增加缓存失效调用；验证安装/卸载后的数据一致性。

回滚策略：保留原有“仅注册表列表”路径开关；若缓存或增强逻辑异常，可临时禁用增强与缓存并退回基础列表。

## Open Questions

- 缓存首版是否需要记录“每条记录级别”的失效时间，还是先采用“整表 TTL”？
- 占用空间目录扫描是否默认开启，还是由前端显式触发“计算真实占用”？
- 图标返回格式最终是否保持文件路径，还是在后续迭代中支持二进制/缩略图缓存？
